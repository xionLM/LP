# LP
语言处理器 
这是个编译器前端,类似于m4宏处理器,可以实现语言(自然语言,编程语言)之间的翻译转换以及数据的压缩解压缩 
## 语法
8个基本语法符号
\# 预处理器(preprocessor),在对代码编译之前导入其他的lp文件
> \# predefine 导入预定义的predefine.lp文件 
'  语法引用(quote):对引用部分转义,引用部分的符号不进行语法分析做为字面量处理
> ' -> ' 此内的->不做语法符号,当做为字面量符号处理
宏:3个宏符号,以新行为开始,以换行符为结尾,如果需要匹配替换的代码段中包含换行符,请使用''把换行符包裹起来,从全文的下一个段落开始进行搜索匹配,如果找到符号宏规则式左部的代码则用右部替换
-> 定义(define):宏替换,字面量替换
<- 取消定义(undefine),阻断宏的语法作用
<->展开(expan)
> 如果匹配的位置在宏内,做为变长参数匹配的宏
> a <-> b ,
> c a d -> e
> c b , b , b , b , b , d .
> e .                           替换后的
> 如果匹配的位置在宏外,做为缺省匹配宏的代码语句
> a <-> ()
> c b d  -> f
> c a .
> f .                           替换后的
( )词组,短语(phrase):表达式
{ }模板(template)
: 模板选项(option)
## 自然语言翻译
### 简单的词语替换
> apple -> 苹果
### 改变句式顺序
> { 主语 } { 动词 } { 宾语 } -> { 宾语 } 被 { 主语 } { 动词 } 了
> 我 打 你           原始语句
> 你 被 我 打 了     替换后的语句
## 编程语言转换
### 用自然语言或者面向对象的书写格式来解决函数层叠调用嵌套所造成满屏括号的问题
>{ number1 } add { number2 } -> add( { number1 } ,  { number2 } )
> 1 add 2            原始语句 
> add( 1 , 2 )       替换后的语句
利用这种特性可以很容易的写出自然语言或者面向对象的代码并将其转换成等价函数式形式
## 数据的压缩和解压缩
> 11111111111111111111111111111111111111111111111 -> 101 
> 11111111111111111111111111111111111111111111111  原始数据
> 101                                              压缩后的数据 
